---
title: "Cross_multiple_genes"
output: html_document
date: "2023-08-26"
---

Packages
```{r global-options, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>"
)
library(BiocStyle)
library(MoleculeExperiment)
library(ggplot2)
library(dplyr)
library(purrr)
library(tidyr)
library(sf)
library(stringr)
library(Matrix)
library(stats)
library(lmtest)
library(tidyverse)
library(deldir)
library(sp)
library(rgeos)
library(caret)
```

Read demo data
```{r}
repoDir <- system.file("extdata", package = "MoleculeExperiment")
repoDir <- paste0(repoDir, "/xenium_V1_FF_Mouse_Brain")
me <- readXenium(repoDir,
  keepCols = "essential",
  addBoundaries = "cell"
)
me
```

Show the molecules and boundaries dataframe
```{r}
MoleculeExperiment::molecules(me, assayName = "detected", flatten = TRUE)
MoleculeExperiment::boundaries(me, assayName = "cell", flatten = TRUE)
```

```{r}
# Function to extract boundaries
extract_boundaries <- function(me) {
  df_boundary <- data.frame(boundaries(me, assayName = "cell", flatten = TRUE))
  return(df_boundary)
}
df = extract_boundaries(me)

# Function to calculate distance between two points
distance <- function(x1, y1, x2, y2) {
  sqrt((x1 - x2)^2 + (y1 - y2)^2)
}

# Function to check if two cells are neighbors based on their boundary points
are_neighbors <- function(df1, df2, threshold) {
  for(i in 1:nrow(df1)) {
    for(j in 1:nrow(df2)) {
      if (distance(df1$x_location[i], df1$y_location[i], df2$x_location[j], df2$y_location[j]) < threshold) {
        for(k in i:nrow(df1)) {
          for(l in j:nrow(df2)) {
            if(k != i & l != j & distance(df1$x_location[k], df1$y_location[k], df2$x_location[l], df2$y_location[l]) < threshold) {
              return(TRUE)
            }
          }
        }
      }
    }
  }
  return(FALSE)
}

# Function to get neighbors for a given cell in a dataframe
get_neighbors <- function(cell_id, df, threshold = 1) {
  cell_data <- df %>% filter(segment_id == cell_id)
  potential_neighbors <- df %>% filter(sample_id == cell_data$sample_id[1] & segment_id != cell_id)
  neighbor_ids <- unique(potential_neighbors$segment_id)
  
  true_neighbors <- sapply(neighbor_ids, function(id) {
    neighbor_data <- df %>% filter(segment_id == id)
    are_neighbors(cell_data, neighbor_data, threshold)
  })
  
  neighbor_ids[true_neighbors]
}

# Function to get neighbors for all cells and save to dataframe
get_all_neighbors <- function(df, threshold = 1) {
  all_cells <- unique(df$segment_id)
  results <- list()

  for(cell_id in all_cells) {
    cell_sample_id <- df %>% filter(segment_id == cell_id) %>% select(sample_id) %>% distinct() %>% pull(sample_id)
    neighbors <- get_neighbors(cell_id, df, threshold)
    
    for(neighbor in neighbors) {
      neighbor_sample_id <- df %>% filter(segment_id == neighbor) %>% select(sample_id) %>% distinct() %>% pull(sample_id)
      results[[length(results) + 1]] <- data.frame(cell = paste(cell_sample_id, cell_id, sep = "."), 
                                                   neighbor = paste(neighbor_sample_id, neighbor, sep = "."))
    }
  }
  
  do.call(rbind, results)
}

cellneighbours = get_all_neighbors(df)
cellneighbours
```

```{r}
ggplot_me() +
  # add molecule points and colour by feature name
  geom_point_me(me, byColour = "feature_name", size = 0.1) +
  # add cell segments and colour by cell id
  geom_polygon_me(me, byFill = "segment_id", colour = "black", alpha = 0.1) +
  # zoom in to selected patch area
  coord_cartesian(xlim = c(4900, 4919.98), ylim = c(6400.02, 6420))
```

```{r}
library(SpatialExperiment)
cell = countMolecules(
  me,
  moleculesAssay = "detected",
  boundariesAssay = "cell",
  buffer = 0,
  matrixOnly = FALSE,
  nCores = 1
)
```

```{r}
counts(cell)
```

```{r}
# Assuming `me` is your SpatialExperiment object and `df` is your boundary data
df = extract_boundaries(me)
cellneighbours = get_all_neighbors(df)

# Your dgCMatrix
mat <- counts(cell)

# Extract neighbors from cellneighbours for each cell
get_cell_neighbours <- function(cell_id) {
  neighbours <- cellneighbours %>% 
    filter(cell == cell_id) %>%
    pull(neighbor)
  return(neighbours)
}

# Sum up gene counts from neighbors
get_neighbour_counts <- function(cell_id) {
  neighbours <- get_cell_neighbours(cell_id)
  # if no neighbours found or the neighbours are not columns in mat, return zero matrix
  if(length(neighbours) == 0 || all(!neighbours %in% colnames(mat))) {
    return(matrix(0, nrow=nrow(mat), ncol=1))
  }
  
  neighbour_mat <- mat[, neighbours, drop=FALSE]
  gene_counts <- rowSums(neighbour_mat, na.rm = TRUE)
  return(matrix(gene_counts, nrow=length(gene_counts), ncol=1))
}

# Create a matrix to store neighbour sums
neighbour_sums <- matrix(0, nrow=nrow(mat), ncol=ncol(mat))
colnames(neighbour_sums) <- paste0(colnames(mat), "_n")

# Calculate neighbour sums
for(cell in colnames(mat)) {
  neighbour_sums[, paste0(cell, "_n")] <- get_neighbour_counts(cell)
}

# Combine the matrices
combined_mat <- cbind(mat, neighbour_sums)

# First, get the base column names without the '_n' suffix
base_names <- gsub("_n$", "", colnames(combined_mat))

# Use match to order the base names, and then alternate between the base and its corresponding "_n" column
ordered_indices <- as.vector(rbind(match(base_names, colnames(combined_mat)), 
                                   match(paste0(base_names, "_n"), colnames(combined_mat))))

# Subset the matrix with the ordered indices to rearrange columns
combined_mat <- combined_mat[, ordered_indices]

# Convert back to a sparse matrix if desired
mat_sparse_ordered <- as(combined_mat, "dgCMatrix")
mat_sparse_ordered
```

$\frac{\left(a\times d\right)-\left(b\times c\right)}{\sqrt{\left(a+b\right)\left(a+c\right)\left(b+d\right)\left(c+d\right)}}$

```{r}
mat_sparse <- as(combined_mat, "dgCMatrix")

# Compute MCC for a given 2x2 table
compute_mcc <- function(table) {
  a <- table[1, 1]
  b <- table[1, 2]
  c <- table[2, 1]
  d <- table[2, 2]
  
  denominator <- sqrt((a+b)*(a+c)*(b+d)*(c+d))
  if (denominator == 0) {
    return(0)
  } else {
    return((a*d - b*c) / denominator)
  }
}

calculate_mcc_for_cell <- function(cell_col, neighbor_col) {
  # Generating all ordered pairs of genes
  gene_pairs <- expand.grid(rownames(mat_sparse), rownames(mat_sparse))
  
  # Removing pairs where both genes are the same
  gene_pairs <- gene_pairs[gene_pairs$Var1 != gene_pairs$Var2, ]

  sapply(1:nrow(gene_pairs), function(i) {
    gene1 <- gene_pairs$Var1[i]
    gene2 <- gene_pairs$Var2[i]
    
    table <- matrix(0, 2, 2)
    table[1, 1] <- sum(cell_col[gene1, ] > 0 & cell_col[gene2, ] > 0)
    table[1, 2] <- sum(cell_col[gene1, ] > 0 & neighbor_col[gene2, ] > 0)
    table[2, 1] <- sum(neighbor_col[gene1, ] > 0 & cell_col[gene2, ] > 0)
    table[2, 2] <- sum(neighbor_col[gene1, ] > 0 & neighbor_col[gene2, ] > 0)
    
    compute_mcc(table)
  }) %>% 
  set_names(paste(gene_pairs$Var1, gene_pairs$Var2, sep="_"))
}

# Compute MCC for all cells
results <- lapply(seq(1, ncol(mat_sparse), by=2), function(i) {
  cell_col <- mat_sparse[, i, drop=FALSE]
  neighbor_col <- mat_sparse[, i+1, drop=FALSE]
  calculate_mcc_for_cell(cell_col, neighbor_col)
})

df <- do.call(cbind, results)
colnames(df) <- colnames(mat_sparse)[seq(1, ncol(mat_sparse), by=2)]

df

```

```{r}
mat_sparse <- as(combined_mat, "dgCMatrix")

# Compute MCC for a given 2x2 table
compute_mcc <- function(table) {
  a <- table[1, 1]
  b <- table[1, 2]
  c <- table[2, 1]
  d <- table[2, 2]
  
  denominator <- sqrt((a+b)*(a+c)*(b+d)*(c+d))
  if (denominator == 0) {
    return(0)
  } else {
    return((a*d - b*c) / denominator)
  }
}

# Calculate MCC for all pairs of genes for a given cell and its neighbors
calculate_mcc_for_cell <- function(cell_col, neighbor_col) {
  # Generating all ordered pairs of genes
  gene_pairs <- expand.grid(rownames(mat_sparse), rownames(mat_sparse))
  
  # Removing pairs where both genes are the same
  gene_pairs <- gene_pairs[gene_pairs$Var1 != gene_pairs$Var2, ]

  sapply(1:nrow(gene_pairs), function(i) {
    gene1 <- gene_pairs$Var1[i]
    gene2 <- gene_pairs$Var2[i]
    
    table <- matrix(0, 2, 2)
    table[1, 1] <- cell_col[gene1, ]
    table[1, 2] <- neighbor_col[gene1, ]
    table[2, 1] <- cell_col[gene2, ]
    table[2, 2] <- neighbor_col[gene2, ]
    
    compute_mcc(table)
  }) %>% 
  set_names(paste(gene_pairs[1,], gene_pairs[2,], sep="_"))
}

# Compute MCC for all cells
results <- lapply(seq(1, ncol(mat_sparse), by=2), function(i) {
  cell_col <- mat_sparse[, i, drop=FALSE]
  neighbor_col <- mat_sparse[, i+1, drop=FALSE]
  calculate_mcc_for_cell(cell_col, neighbor_col)
})

df <- do.call(cbind, results)
colnames(df) <- colnames(mat_sparse)[seq(1, ncol(mat_sparse), by=2)]

df

```


